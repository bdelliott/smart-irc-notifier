#!/usr/bin/env python
"""
Send a email/SMS notification if the user is idle on their laptop.

Idle is determined by the user running a program on their laptop
(client-irc-notifier) which constantly sends idle-time back to the server where
this script runs.

This script doesn't exit and is intended to be run inside a GNU screen
session window

Configure using .irssi/server-irc-notifier.cfg
"""

import ConfigParser
from email.mime.text import MIMEText
import os
import smtplib
import subprocess
import sys
import time


CONFIG_FILE = '.irssi/server-irc-notifier.cfg'
IDLE_TIME_PATH = '.irssi/idle-time'
FORCE_IDLE_PATH = '.irssi/force-idle'
FNOTIFY_LOG = '.irssi/fnotify'
DEFAULT_POLL_INTERVAL = 1.0


def get_idle_time_and_age():
    if os.path.exists(IDLE_TIME_PATH):
        with open(IDLE_TIME_PATH) as f:
            idle_time = float(f.read().strip())
            age = time.time() - os.path.getmtime(IDLE_TIME_PATH)
            return (idle_time, age)
    return (None, None)


def is_idle(cfg, idle_time, age):
    """Determine whether the user is considered idle.

    A script on the users laptop is updating the local `idle-time` file.

    If the `idle-time` file doesn't exist, then the user is by definition idle
    (because they haven't logged in to create it).

    Alternatively, the user can be 'forcing' a particular mode; this is
    signaled by the `force-idle` file with the following values:

            0 NORMAL
            1 FORCE IDLE
            2 FORCE NOT IDLE

    If the `idle-time` file is present, we have two possibilities:

        1) File hasn't been touched in a while: This means the laptop is no
        longer active (from our perspective) and we should consider the user
        idle.

        2) The file has been touched recently: In this case the laptop is
        active (since we're receiving idle reports), however the user might
        not be at their desk. So in this case, use the contents of `idle-time`
        file to determine what to do.
    """
    # Check for force values first...
    if os.path.exists(FORCE_IDLE_PATH):
        with open(FORCE_IDLE_PATH) as f:
            force_val = int(f.read().strip())
        if force_val == 1:
            print "IDLE: forced"
            return True
        elif force_val == 2:
            print "NOT IDLE: forced"
            return False
        else:
            print "Leaving force mode..."
            os.unlink(FORCE_IDLE_PATH)
            # Fall through to normal logic...

    # Ensure idle-time file exists...
    if not idle_time and not age:
        print "IDLE: Idle file doesn't exist"
        return True

    # Ensure idle-time file isn't stale
    if age > idle_threshold:
        print "IDLE: Idle file is stale: {} > {}".format(age, idle_threshold)
        return True

    idle_threshold  = cfg.getint('general', 'idle')

    # Ensure contents (idle-time) are under threshold
    if idle_time > idle_threshold:
        print "IDLE: threshold exceeded, {} > {}".format(
                idle_time, idle_threshold)
        return True
    else:
        print "NOT IDLE: under threshold , {} <= {}".format(
                idle_time, idle_threshold)
        return False


def notify_email(cfg, body):
    print "Sending Notification: ", body
    host = cfg.get('email', 'smtp_host')
    assert host
    server = smtp_connect(host,
                          cfg.get('email', 'smtp_user'),
                          cfg.get('email', 'smtp_password'))
    try:
        smtp_send(server,
                  cfg.get('email', 'from_email'),
                  cfg.get('email', 'to_email'),
                  body=body)
    finally:
        smtp_close(server)


def smtp_connect(host, user, password):
    server = smtplib.SMTP(host)
    server.ehlo()
    server.starttls()
    server.login(user, password)
    return server


def smtp_close(server):
    server.quit()


def smtp_send(server, from_email, to_email, body=None, subject=None):
    msg = MIMEText(body)
    if subject:
        msg['Subject'] = subject
    msg['From'] = from_email
    msg['To'] = to_email
    server.sendmail(from_email, [to_email], msg.as_string())


def main():
    if not os.path.exists(CONFIG_FILE):
        print "error: required config file not found at '{}'".format(CONFIG_FILE)
        sys.exit(1)
    cfg = ConfigParser.ConfigParser()
    cfg.read(CONFIG_FILE)
    try:
        poll_interval  = cfg.getfloat('general', 'poll_interval')
    except ConfigParser.NoOptionError:
        poll_interval = DEFAULT_POLL_INTERVAL

    last_fnotify_mtime =  os.path.getmtime(FNOTIFY_LOG)

    while True:
        idle_time, age = get_idle_time_and_age()
        print "idle_time = {}, age = {}".format(idle_time, age)

        # Only process if fnotify file was updated since last read...
        cur_fnotify_mtime =  os.path.getmtime(FNOTIFY_LOG)
        if cur_fnotify_mtime != last_fnotify_mtime:
            last_fnotify_mtime = cur_fnotify_mtime

            if is_idle(cfg, idle_time, age):
                with open(FNOTIFY_LOG) as f:
                    last_line =  f.read().splitlines()[-1]
                    notify_email(cfg, last_line)

        time.sleep(poll_interval)


if __name__ == '__main__':
    main()
